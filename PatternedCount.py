# PatternedCount.py
# Auto-numbered sketch text for patterned counter segments.
#
# Usage:
# 1. Create user parameters:
#    - pcSegmentCount   (unitless int, e.g. 10)
#    - pcSegmentPitch   (length, e.g. 6 mm) - for linear mode
#    - pcStartNumber    (unitless int, e.g. 0)
#    - pcDirection      (text: "+X", "-X", "+Y", "-Y"; optional, default "+X") - for linear mode
#    - pcArcDirection   (text: "CW" or "CCW"; optional, default "CCW") - for circular mode
#    - pcCutDepth       (length, e.g. 0.4 mm; optional - enables cut/body creation)
#
# 2. Create a sketch on a face, add ONE Sketch Text as the template.
#    - For circular mode: select a guide circle before running
# 3. Select the sketch in the browser (or edit it).
# 4. Run this script from Scripts & Add-Ins.

import adsk.core
import adsk.fusion
import traceback
import math

# Prefix for generated features - only items with this prefix will be auto-deleted
GENERATED_PREFIX = "pc#"
# Attribute group/name used to tag generated sketch texts
ATTR_GROUP = "PatternedCount"
ATTR_NAME = "generated"


def _get_user_param(design, name, required=True):
    params = design.userParameters
    p = params.itemByName(name)
    if not p and required:
        raise RuntimeError(f'Missing user parameter "{name}".')
    return p


def _find_sketch(design, ui):
    """Find the target sketch by selection or active edit object."""
    sel = ui.activeSelections

    # Check if user has a sketch selected
    if sel.count >= 1:
        for i in range(sel.count):
            ent = sel.item(i).entity
            sketch = adsk.fusion.Sketch.cast(ent)
            if sketch:
                return sketch

            # Check if a sketch circle is selected - infer sketch from it
            circle = adsk.fusion.SketchCircle.cast(ent)
            if circle:
                return circle.parentSketch

            # Check if a sketch text is selected - infer sketch from it
            text = adsk.fusion.SketchText.cast(ent)
            if text:
                return text.parentSketch

    # Check if we're currently editing a sketch
    app = adsk.core.Application.get()
    edit_obj = app.activeEditObject
    sketch = adsk.fusion.Sketch.cast(edit_obj)
    if sketch:
        return sketch

    return None


def _is_generated(text):
    """Check if a SketchText was generated by this script (has our attribute)."""
    attr = text.attributes.itemByName(ATTR_GROUP, ATTR_NAME)
    return attr is not None


def _find_template_text(sketch, ui):
    """Find the template text in the sketch (non-generated text)."""
    texts = sketch.sketchTexts
    if texts.count == 0:
        return None

    # Find texts that are NOT generated (don't have our attribute)
    non_generated = []
    for i in range(texts.count):
        t = texts.item(i)
        if not _is_generated(t):
            non_generated.append(t)

    if len(non_generated) == 1:
        return non_generated[0]
    elif len(non_generated) == 0:
        # All texts are generated - should not happen, but fallback to first
        return texts.item(0) if texts.count > 0 else None
    else:
        # Multiple non-generated texts - check selection
        sel = ui.activeSelections
        if sel.count == 1:
            selected_text = adsk.fusion.SketchText.cast(sel.item(0).entity)
            if selected_text and selected_text.parentSketch == sketch:
                return selected_text
        return None


def _delete_generated_features(design):
    """Delete previously generated extrude features."""
    for comp in design.allComponents:
        features = comp.features.extrudeFeatures
        # Iterate in reverse to safely delete
        for i in range(features.count - 1, -1, -1):
            f = features.item(i)
            if f.name.startswith(GENERATED_PREFIX):
                f.deleteMe()


def _find_circle(sketch, ui):
    """Find the guide circle in the sketch. Returns (center_point, radius, circle_entity) or None.

    Requires the user to select a circle explicitly for circular mode.
    """
    # Check if user has a circle selected
    sel = ui.activeSelections
    for i in range(sel.count):
        ent = sel.item(i).entity
        circle = adsk.fusion.SketchCircle.cast(ent)
        if circle and circle.parentSketch == sketch:
            return (circle.centerSketchPoint.geometry, circle.radius, circle)

    return None


def _has_excluded_curves(profile, guide_circle, guide_center, guide_radius_val):
    """Check if a profile contains excluded geometry (reference, construction, or guide circle)."""
    try:
        for loop in profile.profileLoops:
            for curve in loop.profileCurves:
                ent = curve.sketchEntity
                # Check if it's a projected entity (references external geometry)
                if hasattr(ent, 'isReference') and ent.isReference:
                    return True
                # Check if it's construction geometry
                if hasattr(ent, 'isConstruction') and ent.isConstruction:
                    return True
                # Check if it's the guide circle (in circular mode)
                if guide_circle and ent == guide_circle:
                    return True
                # Check if it's an arc from the guide circle (when circle is split by text)
                if guide_center and guide_radius_val:
                    arc = adsk.fusion.SketchArc.cast(ent)
                    if arc:
                        arc_center = arc.centerSketchPoint.geometry
                        arc_radius = arc.radius
                        # Check if arc matches guide circle geometry (with tolerance)
                        center_dist = math.sqrt(
                            (arc_center.x - guide_center.x)**2 +
                            (arc_center.y - guide_center.y)**2
                        )
                        # Use 0.01 cm (0.1mm) tolerance
                        if center_dist < 0.01 and abs(arc_radius - guide_radius_val) < 0.01:
                            return True
    except:
        pass
    return False


def _generate_texts(sketch, template_text, seg_count, start_number, is_circular,
                    circle_center=None, circle_radius=None, segment_angle=None,
                    pitch=None, dir_x=None, dir_y=None):
    """Generate numbered text copies from template."""
    texts = sketch.sketchTexts

    # Make sure template shows the start number
    template_param = template_text.textParameter
    label0 = str(start_number)
    template_param.expression = f"'{label0}'"

    # Determine template center in sketch space
    tpl_box = template_text.boundingBox
    tpl_min = tpl_box.minPoint
    tpl_max = tpl_box.maxPoint
    base_cx = (tpl_min.x + tpl_max.x) * 0.5
    base_cy = (tpl_min.y + tpl_max.y) * 0.5

    # Auto-delete: only remove texts we previously generated (have our attribute)
    for i in range(texts.count - 1, -1, -1):
        t = texts.item(i)
        if _is_generated(t):
            t.deleteMe()

    # For circular mode, calculate starting angle from template position
    start_angle = 0.0
    if is_circular:
        dx_from_center = base_cx - circle_center.x
        dy_from_center = base_cy - circle_center.y
        start_angle = math.atan2(dy_from_center, dx_from_center)

    # Generate texts for segments 1..seg_count-1
    for i in range(1, seg_count):
        n = start_number + i
        label = str(n)

        # Copy the template text
        copy_coll = adsk.core.ObjectCollection.create()
        copy_coll.add(template_text)
        new_entities = sketch.copy(copy_coll, adsk.core.Matrix3D.create())
        new_text = adsk.fusion.SketchText.cast(new_entities.item(0))

        # Update the text content
        new_text.textParameter.expression = f"'{label}'"
        # Tag as generated so we can identify and delete it later
        new_text.attributes.add(ATTR_GROUP, ATTR_NAME, label)

        # Compute current center of copied text
        nb = new_text.boundingBox
        nmin = nb.minPoint
        nmax = nb.maxPoint
        cur_cx = (nmin.x + nmax.x) * 0.5
        cur_cy = (nmin.y + nmax.y) * 0.5

        if is_circular:
            # Circular mode: position on circle
            angle_offset = i * segment_angle
            target_angle = start_angle + angle_offset
            target_cx = circle_center.x + circle_radius * math.cos(target_angle)
            target_cy = circle_center.y + circle_radius * math.sin(target_angle)
        else:
            # Linear mode: simple translation
            step = i * pitch
            target_cx = base_cx + step * dir_x
            target_cy = base_cy + step * dir_y

        dx = target_cx - cur_cx
        dy = target_cy - cur_cy

        xform = adsk.core.Matrix3D.create()
        xform.translation = adsk.core.Vector3D.create(dx, dy, 0)

        coll = adsk.core.ObjectCollection.create()
        coll.add(new_text)
        sketch.move(coll, xform)

    return base_cx, base_cy, start_angle


def _collect_text_boxes(texts, start_number, is_circular, segment_angle):
    """Collect text bounding boxes and metadata before exploding."""
    text_boxes = []
    for i in range(texts.count):
        t = texts.item(i)
        bb = t.boundingBox
        text_content = t.text
        cx = (bb.minPoint.x + bb.maxPoint.x) * 0.5
        cy = (bb.minPoint.y + bb.maxPoint.y) * 0.5

        rotation_angle = 0.0
        if is_circular:
            try:
                num_val = int(text_content)
                segment_idx = num_val - start_number
                rotation_angle = segment_idx * segment_angle
            except:
                pass

        text_boxes.append({
            'min': bb.minPoint,
            'max': bb.maxPoint,
            'centroid': (cx, cy),
            'number': text_content,
            'rotation': rotation_angle
        })
    return text_boxes


def _explode_texts(sketch):
    """Explode all texts in sketch to curves."""
    texts = sketch.sketchTexts
    texts_to_explode = []
    for i in range(texts.count):
        texts_to_explode.append(texts.item(i))

    for t in texts_to_explode:
        try:
            t.textParameter.expression = t.textParameter.expression
        except:
            pass
        try:
            t.explode()
        except:
            pass


def _rotate_curves_circular(sketch, text_boxes):
    """Rotate exploded curves for circular mode."""
    # Delete all sketch constraints to allow free movement
    try:
        constraints = sketch.geometricConstraints
        for i in range(constraints.count - 1, -1, -1):
            constraints.item(i).deleteMe()
    except:
        pass

    curves_to_delete = []

    for tb in text_boxes:
        if tb['rotation'] == 0.0:
            continue  # Skip template (no rotation needed)

        rot_cx, rot_cy = tb['centroid']
        rot_angle = tb['rotation']
        min_pt, max_pt = tb['min'], tb['max']

        # Find curves whose center is within this text's bounding box
        tol = 0.1
        curves_for_this_text = adsk.core.ObjectCollection.create()

        for i in range(sketch.sketchCurves.count):
            curve = sketch.sketchCurves.item(i)
            try:
                bb = curve.boundingBox
                curve_cx = (bb.minPoint.x + bb.maxPoint.x) / 2
                curve_cy = (bb.minPoint.y + bb.maxPoint.y) / 2

                if (min_pt.x - tol <= curve_cx <= max_pt.x + tol and
                    min_pt.y - tol <= curve_cy <= max_pt.y + tol):
                    curves_for_this_text.add(curve)
            except:
                pass

        if curves_for_this_text.count > 0:
            rot_xform = adsk.core.Matrix3D.create()
            rot_xform.setToRotation(
                rot_angle,
                adsk.core.Vector3D.create(0, 0, 1),
                adsk.core.Point3D.create(rot_cx, rot_cy, 0)
            )
            try:
                new_curves = sketch.copy(curves_for_this_text, rot_xform)
                if new_curves and new_curves.count > 0:
                    for j in range(curves_for_this_text.count):
                        curves_to_delete.append(curves_for_this_text.item(j))
            except:
                pass

    # Batch delete original curves
    for curve in curves_to_delete:
        try:
            curve.deleteMe()
        except:
            pass


def _collect_valid_profiles(sketch, text_boxes, text_height, max_char_area, is_circular,
                            guide_circle, guide_center, guide_radius_val):
    """Collect profiles that belong to text characters."""
    valid_profiles = []
    profiles = sketch.profiles

    for i in range(profiles.count):
        profile = profiles.item(i)
        try:
            if _has_excluded_curves(profile, guide_circle, guide_center, guide_radius_val):
                continue

            area_props = profile.areaProperties()
            centroid = area_props.centroid
            area = area_props.area
            cx, cy = centroid.x, centroid.y

            if area > max_char_area:
                continue

            matched_number = None
            if is_circular:
                best_dist = float('inf')
                for tb in text_boxes:
                    tcx, tcy = tb['centroid']
                    dist = math.sqrt((cx - tcx)**2 + (cy - tcy)**2)
                    if dist < best_dist:
                        best_dist = dist
                        matched_number = tb['number']
                if best_dist > text_height * 2:
                    matched_number = None
            else:
                for tb in text_boxes:
                    min_pt, max_pt = tb['min'], tb['max']
                    if (min_pt.x <= cx <= max_pt.x and min_pt.y <= cy <= max_pt.y):
                        matched_number = tb['number']
                        break

            if matched_number is not None:
                bb = profile.boundingBox
                valid_profiles.append({
                    'profile': profile,
                    'area': area,
                    'centroid': (cx, cy),
                    'min': (bb.minPoint.x, bb.minPoint.y),
                    'max': (bb.maxPoint.x, bb.maxPoint.y),
                    'number': matched_number
                })
        except:
            pass

    return valid_profiles


def _filter_outer_profiles(valid_profiles):
    """Filter out inner profiles (holes inside other profiles)."""
    def is_contained_in(inner, outer):
        return (outer['min'][0] < inner['min'][0] and
                outer['min'][1] < inner['min'][1] and
                outer['max'][0] > inner['max'][0] and
                outer['max'][1] > inner['max'][1])

    outer_profiles = []
    for p in valid_profiles:
        is_inner = False
        for other in valid_profiles:
            if p is not other and is_contained_in(p, other):
                is_inner = True
                break
        if not is_inner:
            outer_profiles.append(p)

    return outer_profiles


def _create_cuts_and_bodies(comp, sketch, outer_profiles, cut_depth, text_boxes, is_circular,
                            circle_radius=None, segment_angle=None, pitch=None):
    """Create cut features and body extrusions."""
    extrudes = comp.features.extrudeFeatures
    cuts_created = 0
    bodies_created = 0
    cut_errors = []
    body_errors = []

    profile_collection = adsk.core.ObjectCollection.create()
    for p in outer_profiles:
        profile_collection.add(p['profile'])

    if profile_collection.count == 0:
        return 0, 0, cut_errors, body_errors

    # Create a single cut with all profiles
    cut_input = extrudes.createInput(
        profile_collection,
        adsk.fusion.FeatureOperations.CutFeatureOperation
    )
    cut_distance = adsk.core.ValueInput.createByReal(-cut_depth)
    cut_input.setDistanceExtent(False, cut_distance)

    try:
        cut_feature = extrudes.add(cut_input)
        cut_feature.name = f"{GENERATED_PREFIX}cuts"
        cuts_created = profile_collection.count
    except Exception as e:
        cut_errors.append(str(e))
        return 0, 0, cut_errors, body_errors

    # Create new bodies from the cut's end faces
    try:
        end_faces = cut_feature.endFaces
        sketch_transform = sketch.transform
        sketch_transform_inv = sketch_transform.copy()
        sketch_transform_inv.invert()

        if is_circular:
            tol = circle_radius * abs(segment_angle) * 0.5
        else:
            tol = pitch * 0.5

        for j in range(end_faces.count):
            face = end_faces.item(j)
            try:
                face_centroid = face.centroid
                sketch_centroid = face_centroid.copy()
                sketch_centroid.transformBy(sketch_transform_inv)
                fcx, fcy = sketch_centroid.x, sketch_centroid.y

                face_number = None
                if is_circular:
                    best_dist = float('inf')
                    for tb in text_boxes:
                        tcx, tcy = tb['centroid']
                        dist = math.sqrt((fcx - tcx)**2 + (fcy - tcy)**2)
                        if dist < best_dist:
                            best_dist = dist
                            face_number = tb['number']
                    if best_dist > tol:
                        face_number = None
                else:
                    for tb in text_boxes:
                        min_pt, max_pt = tb['min'], tb['max']
                        if (min_pt.x - tol <= fcx <= max_pt.x + tol and
                            min_pt.y - tol <= fcy <= max_pt.y + tol):
                            face_number = tb['number']
                            break

                body_input = extrudes.createInput(
                    face,
                    adsk.fusion.FeatureOperations.NewBodyFeatureOperation
                )
                body_distance = adsk.core.ValueInput.createByReal(cut_depth)
                body_input.setDistanceExtent(False, body_distance)
                body_feature = extrudes.add(body_input)
                body_feature.name = f"{GENERATED_PREFIX}body_{j}"

                if body_feature.bodies.count > 0:
                    new_body = body_feature.bodies.item(0)
                    if face_number is not None:
                        new_body.name = f"n{face_number}"

                bodies_created += 1
            except Exception as e:
                body_errors.append(f"Face {j}: {str(e)}")
    except Exception as e:
        body_errors.append(str(e))

    return cuts_created, bodies_created, cut_errors, body_errors


def _run_impl(app, ui):
    """Main implementation logic."""
    design = adsk.fusion.Design.cast(app.activeProduct)
    if not design:
        ui.messageBox('PatternedCount: No active Fusion design.')
        return

    # Start a timeline group so all operations can be undone at once
    timeline = design.timeline
    timeline_start = timeline.markerPosition

    # Find the sketch
    sketch = _find_sketch(design, ui)
    if not sketch:
        ui.messageBox(
            'PatternedCount:\n'
            'No sketch found. Select a sketch in the browser or edit a sketch, '
            'then run the script again.'
        )
        return

    # Find the template text
    template_text = _find_template_text(sketch, ui)
    if not template_text:
        ui.messageBox(
            'PatternedCount:\n'
            'Could not determine template text. Ensure the sketch has exactly '
            'one non-generated text, or select the template text.'
        )
        return

    # Detect circular vs linear mode
    circle_info = _find_circle(sketch, ui)
    is_circular = circle_info is not None

    # Read parameters
    seg_count_param = _get_user_param(design, 'pcSegmentCount')
    start_param = _get_user_param(design, 'pcStartNumber')
    cut_depth_param = _get_user_param(design, 'pcCutDepth', required=False)

    seg_count = int(round(seg_count_param.value))
    if seg_count < 1:
        ui.messageBox('PatternedCount: pcSegmentCount must be at least 1.')
        return

    start_number = int(round(start_param.value))
    cut_depth = cut_depth_param.value if cut_depth_param else None

    # Mode-specific parameters
    circle_center = circle_radius = segment_angle = guide_circle_entity = None
    pitch = dir_x = dir_y = None

    if is_circular:
        circle_center, circle_radius, guide_circle_entity = circle_info
        arc_dir_param = _get_user_param(design, 'pcArcDirection', required=False)
        arc_clockwise = False
        if arc_dir_param:
            arc_str = arc_dir_param.expression.strip().strip("'\"").upper()
            if arc_str == "CW":
                arc_clockwise = True
        segment_angle = 2 * math.pi / seg_count
        if arc_clockwise:
            segment_angle = -segment_angle
    else:
        pitch_param = _get_user_param(design, 'pcSegmentPitch')
        dir_param = _get_user_param(design, 'pcDirection', required=False)
        pitch = pitch_param.value
        dir_x, dir_y = 1, 0
        if dir_param:
            dir_str = dir_param.expression.strip().strip("'\"").upper()
            if dir_str == "-X":
                dir_x, dir_y = -1, 0
            elif dir_str == "+Y":
                dir_x, dir_y = 0, 1
            elif dir_str == "-Y":
                dir_x, dir_y = 0, -1

    # Ensure sketch is visible
    sketch.isLightBulbOn = True

    # Generate texts
    _generate_texts(
        sketch, template_text, seg_count, start_number, is_circular,
        circle_center, circle_radius, segment_angle, pitch, dir_x, dir_y
    )

    # Create cuts and bodies if pcCutDepth is set
    cuts_created = 0
    bodies_created = 0
    cut_errors = []
    body_errors = []

    if cut_depth and cut_depth > 0:
        # Exit sketch edit mode if needed
        if app.activeEditObject and app.activeEditObject.classType == adsk.fusion.Sketch.classType:
            app.activeViewport.refresh()
            design.rootComponent.activate()

        _delete_generated_features(design)

        comp = sketch.parentComponent
        texts = sketch.sketchTexts
        text_height = template_text.heightParameter.value

        # Collect text boxes before exploding
        text_boxes = _collect_text_boxes(texts, start_number, is_circular, segment_angle or 0)

        # Explode texts to curves
        _explode_texts(sketch)

        # Rotate curves in circular mode
        if is_circular:
            _rotate_curves_circular(sketch, text_boxes)

        adsk.doEvents()

        # Make guide circle construction geometry
        if is_circular and guide_circle_entity:
            try:
                guide_circle_entity.isConstruction = True
            except:
                pass

        # Calculate max character area threshold
        profile_areas = []
        profiles = sketch.profiles
        for i in range(profiles.count):
            profile = profiles.item(i)
            try:
                area_props = profile.areaProperties()
                centroid = area_props.centroid
                area = area_props.area
                cx, cy = centroid.x, centroid.y
                for tb in text_boxes:
                    min_pt, max_pt = tb['min'], tb['max']
                    if min_pt.x <= cx <= max_pt.x and min_pt.y <= cy <= max_pt.y:
                        profile_areas.append(area)
                        break
            except:
                pass

        if profile_areas:
            sorted_areas = sorted(profile_areas)
            median_area = sorted_areas[len(sorted_areas) // 2]
            max_char_area = median_area * 3
        else:
            if is_circular:
                spacing = circle_radius * abs(segment_angle)
            else:
                spacing = pitch
            max_char_area = spacing * text_height * 2

        # Get guide circle properties for arc matching
        guide_circle = guide_circle_entity if is_circular else None
        guide_center = guide_circle.centerSketchPoint.geometry if guide_circle else None
        guide_radius_val = guide_circle.radius if guide_circle else None

        # Collect and filter profiles
        valid_profiles = _collect_valid_profiles(
            sketch, text_boxes, text_height, max_char_area, is_circular,
            guide_circle, guide_center, guide_radius_val
        )
        outer_profiles = _filter_outer_profiles(valid_profiles)

        if len(outer_profiles) == 0:
            ui.messageBox(
                'PatternedCount:\n'
                'No valid text profiles found in sketch. Cannot create cuts/bodies.\n'
                'Ensure the sketch is on a face of an existing body.'
            )
        else:
            cuts_created, bodies_created, cut_errors, body_errors = _create_cuts_and_bodies(
                comp, sketch, outer_profiles, cut_depth, text_boxes, is_circular,
                circle_radius, segment_angle, pitch
            )

    # Report results
    mode_str = "circular" if is_circular else "linear"
    msg = f'PatternedCount ({mode_str}): Created {seg_count} numbers starting at {start_number}.'
    if cut_depth and cut_depth > 0:
        msg += f'\nCuts: {cuts_created}, Bodies: {bodies_created}'
        if cut_errors:
            msg += f'\nCut errors: {cut_errors[0]}'
        if body_errors:
            msg += f'\nBody errors: {body_errors[0]}'
    ui.messageBox(msg)

    # Group all timeline operations into one undo step
    timeline_end = timeline.markerPosition
    if timeline_end - timeline_start >= 2:
        try:
            timeline_group = timeline.timelineGroups.add(timeline_start, timeline_end - 1)
            timeline_group.name = "PatternedCount"
        except:
            pass


def run(context):
    ui = None
    try:
        app = adsk.core.Application.get()
        ui = app.userInterface
        _run_impl(app, ui)
    except Exception:
        if ui:
            ui.messageBox('PatternedCount failed:\n{}'.format(traceback.format_exc()))


def stop(context):
    pass
